## 캐시

캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.

> 6장에서 배운 프락시에서 캐시 프락시를 이용하면, 원 서버에 접근하지 않고 캐시 프락시에 접근하여 리소스를 가져올 수 있다고 배웠다.

### 캐시의 장점
  
- 불필요한 데이터 전송을 줄여, 네트워크 요금 비용이 줄어든다.
- 네트워크 병목을 줄여준다.
  - 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있다.
- 원 서버에 대한 요청을 줄여준다.
  - 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
- 거리로 인한 지연을 줄여준다.(가까운곳에서 리소스를 가져오기 때문)
- 캐시는 광역 통신망의 제한된 대역폭으로 인한 병목을 개선할 수 있다.

### 갑작스런 요청 쇄도(Flash Crowds)

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다. 갑작스런 사건(뉴스, 속보, 기사, 연예인 사건 등)으로 인해 많은 사람이 거의 동시에
웹 문서에 접근할 때 `갑작스런 요청 쇄도(Flash Crowds)`가 발생한다.

Flash Crowds가 발생하면 트래픽양이 급증하게되어 웹 서버의 심각한 장애를 야기시킨다.

### 거리로 인한 지연

대역폭이 문제가 되지 않더라도 거리가 문제가 될 수 있다.

### 적중과 부적중

캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 

- `(순수) 캐시 적중(cache hit)`
  - 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 존재하면 그것을 이용해 요청이 처리 될 수 있다.
- `캐시 부적중(cache miss)`
  - 캐시에 대응하는 사본이 없으면, 원 서버로 전달된다.
  
### 재검사(Revalidation)

원 서버의 리소스는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
이러한 신선도 검사를 `HTTP Revalidation(HTTP 재검사)`라고 한다.

클라이언트에서 캐시로 사본 요청시 충분히 오래된 리소스에 대해서만 신선도 검사, 재검사를 실시한다.

- `재검사 적중(느린 적중)`
  - 원 서버로부터 객체 데이터를 받아올 필요가 없다.
  - 재검사 필요?
    - 원 서버에 재검사 요청 보냄
      - 콘텐츠(리소스)가 변경되지 않았으면 `304 Not Modified` 응답을 보냄
        - 캐시는 사본이 신선하다는 것을 알았으므로, 표시를 해둔뒤에 클라이언트로 응답을 보냄
        
### 재검사 적중 vs 순수 캐시적중 vs 캐시 부적중 속도비교

순수 캐시적중 > 재검사 적중 > 캐시 부적중 = 재검사 부적중

재검사 적중은 서버로 부터 객체를 받아올 필요는 없기 때문에, 캐시 부적중 보다 빠르다.

재검사 부적중은 신선도 검사 결과가, 유효기간이 지났다고 판정됬을 때를 뜻한다. 이 경우에는 원 서버에서 객체를 받아와야 하기 때문에 캐시 부적중과
속도가 비슷하다.

### If-Modified-Since 헤더

HTTP는 캐시된 객체를 확인하기 위해 몇가지 도구를 제공하는데, 그 중 가장 많이 쓰이는것은 If-Modified-Since 헤더이다. 

GET 요청을 보낼때 If-Modified-Since 헤더를 추가하면 `캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.`

GET If-Modified-Since 요청이 서버에 도착했을때 일어날 수 있는 세가지 경우

1. 서버 콘텐츠가 변경되지 않은 경우
  - 재검사 적중(서버가 304 Not Modified 응답을 보냄)
2. 서버 콘텐츠가 변경된 경우
  - 재검사 부적중(캐시된 사본과, 서버의 콘텐츠가 다른경우, 서버는 콘텐츠 전체(JSON 객체)와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.)
3. 객체가 삭제된 경우
  - 서버는 404 Not Found 응답을 보내며, 캐시는 사본을 삭제한다.
  
### 캐시 적중률

캐시가 요청을 처리하는 비율을 캐시 적중률(캐시 적중비, 문서 적중률, 문서 적중비)라고 한다. 적중률은 0~1까지의 값으로 퍼센트로 표현할 수 도 있다.

- 0% 
  - 모든 요청이 캐시 부적중
- 100%
  - 모든 요청이 캐시 적중
  
 캐시 적중률이 40%정도 되면 웹 캐시로 괜찮은 편이다.
 
### 바이트 적중률

바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이 측정값은 트래픽이 절감된 정도를 포착해낸다.

적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.

### 적중과 부적중 구별

- via 헤더에 추가정보 붙이기
- Date 헤더 이용
  - 응답의 Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.
- Age 헤더 이용

## 캐시 토폴로지

한 사람에게만 할당된 캐시를 `개인 전용 캐시(private cache)`라고 한다.

여러 사람에게 공유된 캐시를 `공용 캐시(public cache)`라고 한다.

### private cache

웹 브라우저는 개인 전용 캐시를 내장하고 있다. 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가
캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

캐시보는 방법은 익스의 경우 `도구 > 인터넷 옵션 > 검색 기록 > 설정 > 파일보기`에서 볼 수 있다.

크롬의 경우 특별한 URL인 `about:cache`를 통해 연결되는 페이지에서 캐시 콘텐츠의 목록을 볼 수 있다.

### public cache

공용 캐시를 프락시 캐시, 캐시 프락시 서버 라고 부른다. 

프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버를 제공한다. 공용 캐시는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을
줄일 수 있는 더 많은 기회가 있다.

## 캐시 처리 단계

오늘날 상용 프락시 캐시는 꽤 복잡하다. 매우 고성능이면서도 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다.

HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져있다.

1. 요청받기
  - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 
  - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색
  - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다. 그리고 로컬에 저장한다.
4. 신선도 검사
  - 캐시는 사본이 충분히 신선한지를 검사하고, 신선하지 않다면 변경사하잉 있는지 서버에 물어본다.
5. 응답 생성
  - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송
  - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅
  - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

## 캐시는 Date 헤더를 조정하면 안된다.

Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이다.

## 문서만료

HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이ㅛㅇ해서 원 서버가 각 문서에서 유효기간을 붙일 수 있게 해준다.

따라서 이 헤더들을 통해서, 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우한다.

캐시가 만료되면 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, 만약 그렇다면 새 유효기간과 함께 신선한 사본을 얻어와야한다.

## 유효기간과 나이

서버는 응답 본문과 함께 하는, HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.

- `Cache-Control:max-age`
  - max-age 값은 문서의 최대 나이를 정의한다.
  - 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값(초 단위)이다.
  - Cache-Control: max-age=484200
- `Expires`
  - 절대 유효기간을 명시한다. 만약 유효기간이 경과했다면, 그 문서는 더 이상 신선하지 않다.
  - Expires: Fri, 08 Jul 2008, 05:00:00 GMT
  
## 서버 재검사

캐시된 문서가 만료되었다는 것은, 원 서버와의 콘텐츠가 다르다는 것을 의미하지는 않으며, 단순히 검사할 시간이 되었다는 것을 뜻한다.

서버 재검사는 `캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미`한다.

- 재검사 결과 콘텐츠가 변경된 경우
  - 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
- 재검사 결과 콘텐츠가 변경되지 않은 경우
  - 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.
  
### 조건부 메서드와의 재검사

HTTP의 조건부 메서드는 재검사를 효율적으로 만들어 준다. 조건부 GET을 붙여 서버에 요청을 보내면 `신선도검사와 함께, 객체를 받아올 수 있다.`
단, 조건이 참인 경우에만 객체를 받아올 수 있다.

HTTP는 다섯 가지 조건부 요청 헤더를 정의하는데, 그 중 둘은 캐시 재검사를 할 때 가장 유용한 `If-Modified-Since`와 `If-None-Match`이다.

모든 조건부 헤더는 If- 접두어로 시작한다.

- `If-Modified-Since` : date(캐시된 마지막 수정일)
  - 만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다. 이것은 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해
  Last-Modified 서버 응답 헤더와 함께 사용된다.
- `If-None-Match` : tags
  - 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동자갛는 특별한 태그를 제공할 수 있다. If-None-Match 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리한다.
  
If-Modified-Since 재검사 요청은 흔히 `IMS` 요청이라 부른다. IMS요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

## 약한 검사기(weak validator)와 강한 검사기(strong validator)

약한 검사기는 비록 콘텐츠가 조금 변경되었더라도 "그 정도면 같은것"이라고 서버가 주장할 수 있도록 해준다.

강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다. 약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경된다.

약한 검사기와 강한 검사기를 구분하는 기준은 `W/` 접두사로 구분한다.

```
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

## 캐시제어

- Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
- Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
- Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
- Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.

### no-cache와 no-store

no-cache와 no-store 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

no-store가 표시괸 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다. 

no-cache로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

no-cache 헤더의 더 나은 이름은 `Do-Not-Serv-From-Cache-Without-Revalidation(재검사 없이 캐시에서 제공하지 마라)`일 것이다.

### max-age 헤더

- Cache-Control: max-age=3600 
- Cache-Control: s-maxage=3600

max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다. 또한 s-maxage 헤더는 max-age 처럼 행동하지만 `공용캐시`에만 적용된다.

### Expires 응답헤더

Expires 헤더는 더 이상 사용하지 않기를 권장하는 헤더이다. Expires 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시한다.

### must-revalidate 헤더

캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정될 수 있다. 만약 캐시가 만료 정보를 엄격하게 따르길 원한다면, 원서버는
다음과 같은 Cache-Control을 붙일 수 있다.

- Cache-Control: must-revalidate
  
## 캐시와 광고

캐시는 성능을 향상시키고 트래픽을 줄이는 효과가 있다는 것을 배웠다.

광고 회사들은 캐시를 무척이나 좋아하는데, 캐시를 사용하면 기사나 광고를 사용자 화면에 빠르게 보여주기 때문에, 사용자들이 더 많은 콘텐츠를 소비하고
더 많은 광고를 보기 때문에, 이익에 직결된다. 
